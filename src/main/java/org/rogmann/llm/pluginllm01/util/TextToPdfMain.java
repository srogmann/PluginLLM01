// TextToPdfMain.java
//
// The initial version of the program was generated by QwQ-32B and then manually adjusted and slightly corrected.
//
// Initial prompt: If we use uncompressed streams, we can generate a .pdf-file using UTF-8-text. Write a Java class TextToPdfMain which has two arguments: TXT-file PDF-output-file. The class should read the txt-file and generate a pdf-file which displays the text line by line (without special formatting or fonts, simple text only). Don't use an external framework, generate the text by writing the PDF-syntax by yourself. Keep track of the bytes written to generate a correct cross-reference at the PDFs end. Es reicht, wenn das Programm nur eine Seite unterstützt, nimm z.B. eine feste Fontgröße von 4 pt, dann passen die gewünschten Textdateien da gut herein. Nimm einen Arial/Helvetica-Standardfont gemäß PDF-Standard. Die Eingabedatei liegt im UTF-8-Encoding vor.
// Second prompt: Great! Please add some JavaDoc and an optional argument [--fontsize <SIZE>] before the filenames.
package org.rogmann.llm.pluginllm01.util;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

/**
 * Converts a UTF-8 text file into a PDF document using a simple text layout.
 * The PDF uses a fixed font (Helvetica) and supports a single page with text displayed line by line.
 * The default font size is 8pt unless specified otherwise.
 */
public class TextToPdfMain {

    /**
     * Main entry point for converting text to PDF.
     * <p>
     * Usage: java TextToPdfMain [ --fontsize <SIZE> ] input.txt output.pdf
     * <p>
     * The --fontsize parameter allows specifying the font size in points (default: 4pt).
     *
     * @param args Command-line arguments
     */
    public static void main(String[] args) {
        int fontSize = 8;
        String inputPath;
        String outputPath;

        // Parse command-line arguments
        if (args.length == 2) {
            inputPath = args[0];
            outputPath = args[1];
        } else if (args.length == 4 && args[0].equals("--fontsize")) {
            try {
                fontSize = Integer.parseInt(args[1]);
                inputPath = args[2];
                outputPath = args[3];
            } catch (NumberFormatException e) {
                System.err.println("Invalid font size: " + args[1]);
                return;
            }
        } else {
            System.err.println("Usage: java TextToPdfMain [ --fontsize <SIZE> ] input.txt output.pdf");
            return;
        }

        // Read input text lines
        List<String> lines = new ArrayList<>();
        try (InputStream fis = new FileInputStream(inputPath);
             InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8);
             BufferedReader br = new BufferedReader(isr)) {
            while (true) {
                String line = br.readLine();
                if (line == null) {
                    break;
                }
                lines.add(line);
            }
        } catch (IOException e) {
            throw new RuntimeException("IO-error while reading " + inputPath, e);
        }
        System.out.format("Read file (%s), %d bytes, %d lines%n", inputPath, new File(inputPath).length(), lines.size());

        byte[] bufPdf = buildPdf(fontSize, lines);

        try {
            // Save to file
            Files.write(Path.of(outputPath), bufPdf);
            System.out.format("Wrote file (%s), %d bytes%n", outputPath, new File(outputPath).length());

        } catch (IOException e) {
            throw new RuntimeException("IO-error while writing " + outputPath, e);
        }
    }

    /**
     * Builds a simple pdf-file containing the lines of text.
     * @param fontSize font-size
     * @param lines lines to print
     * @return pdf-file
     */
    public static byte[] buildPdf(int fontSize, List<String> lines) {
        // Build content stream with dynamic font size and line spacing
        int lineSpacing = fontSize + 1; // Vertical spacing between lines
        StringBuilder contentStreamBuilder = new StringBuilder(500);
        contentStreamBuilder.append("q\nBT\n/F1 ").append(fontSize).append(" Tf\n72 792 Td\n");
        for (String line : lines) {
            String escaped = escapePdfString(line);
            // String converted = new String(escaped.getBytes(StandardCharsets.UTF_16), StandardCharsets.ISO_8859_1);
            String converted = escaped;
            contentStreamBuilder.append("(").append(converted).append(") Tj\n0 -").append(lineSpacing).append(" Td\n");
        }
        contentStreamBuilder.append("ET\nQ\n");
        String contentStreamContent = contentStreamBuilder.toString();
        int contentStreamLength = contentStreamContent.getBytes(StandardCharsets.ISO_8859_1).length;

        // Prepare PDF objects
        String catalog =
            "1 0 obj\n"
            +"<< /Type /Catalog\n"
            + " /Pages 2 0 R\n"
            + ">>\n"
            + "endobj\n";

        String pages =
            "2 0 obj\n"
            +"<< /Type /Pages\n"
            + " /Kids [3 0 R]\n"
            + " /Count 1\n"
            + " /MediaBox [0 0 595 842]\n"
            + ">>\n"
            + "endobj\n";

        String page =
            "3 0 obj\n"
            +"<< /Type /Page\n"
            + " /Parent 2 0 R\n"
            + " /MediaBox [0 0 595 842]\n"
            + " /Contents 4 0 R\n"
            + " /Resources << /Font << /F1 5 0 R >> >>\n"
            + ">>\n"
            + "endobj\n";

        String font =
            "5 0 obj\n"
            +"<< /Type /Font\n"
            + " /Subtype /Type1\n"
            + " /BaseFont /Helvetica\n"
            + " /Encoding /WinAnsiEncoding\n"
            + ">>\n"
            + "endobj\n";

        String contentObj =
            "4 0 obj\n"
            + "<< /Length " + contentStreamLength + " >>\n"
            + "stream\n"
            + contentStreamContent
            + "\nendstream\n"
            + "endobj\n";

        List<String> objects = List.of(catalog, pages, page, contentObj, font);

        // Build PDF structure
        byte[] bufPdf;
        try (ByteArrayStringOutputStream bos = new ByteArrayStringOutputStream()) {
            bos.write("%PDF-1.4\n");

            long[] positions = new long[objects.size()];
            long currentPos = bos.size();

            for (int i = 0; i < objects.size(); i++) {
                String objStr = objects.get(i);
                positions[i] = currentPos;
                bos.write(objStr);
                currentPos += bos.size() - positions[i];
            }

            // Write cross-reference table and trailer
            long xrefStart = bos.size();
            bos.write("xref\n");
            bos.write(String.format("%d %d\n", 0, objects.size()));
            bos.write(String.format("%010d %05d n\r\n", 0, 65535));
            for (int i = 0; i < objects.size(); i++) {
                bos.write(String.format("%010d %05d n\r\n", positions[i], 0));
            }

            bos.write("trailer\n");
            bos.write("<< /Size ");
            bos.write(String.valueOf(objects.size() + 1));
            bos.write("\n /Root 1 0 R\n>>\n");
            bos.write("startxref\n");
            bos.write(String.valueOf(xrefStart));
            bos.write("\n%%%%EOF\n");
            bufPdf = bos.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException("IO-error while building the pdf-file", e);
        }
        return bufPdf;
    }

    /**
     * Escapes special characters in PDF strings.
     * Replaces (, ), and \ characters with their PDF-escaped equivalents.
     *
     * @param s Input string
     * @return Escaped PDF string
     */
    private static String escapePdfString(String s) {
        return s.replace("\\", "\\\\")
                .replace("(", "\\(")
                .replace(")", "\\)")
                .replace("\n", "");
    }

    static class ByteArrayStringOutputStream extends ByteArrayOutputStream {
        public void write(String text) throws IOException {
            write(text.getBytes(StandardCharsets.ISO_8859_1));
        }
    }
}
